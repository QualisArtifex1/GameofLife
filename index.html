<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Conway's Game of Life</title>
  <style>
    body { margin:0; padding:0; font-family:sans-serif; background:#f0f0f0; display:flex; flex-direction:column; align-items:center; }
    #controls { margin:10px; display:flex; gap:0.5rem; }
    #controls button, #controls input { padding:0.5rem; border:1px solid #888; background:#fff; border-radius:4px; cursor:pointer; }
    #controls button:hover, #controls input:hover { background:#eee; }
    #canvas-container { width:600px; max-width:90vw; }
    canvas { width:100%; background:#fff; cursor:pointer; }
    #shapes { display:grid; grid-template-columns:repeat(auto-fill,minmax(60px,1fr)); gap:0.5rem; width:600px; max-width:90vw; margin:10px 0; }
    .shape { background:#eee; border:1px solid #999; border-radius:4px; padding:0.25rem; text-align:center; cursor:grab; }
    #rules { width:600px; max-width:90vw; background:#fff; padding:1rem; border-radius:4px; box-shadow:0 2px 4px rgba(0,0,0,0.1); }
  </style>
</head>
<body>
  <h1>Conway's Game of Life</h1>
  <div id="controls">
    <button id="start">Start</button>
    <button id="stop">Stop</button>
    <button id="clear">Clear</button>
    <label>Speed: <input id="speed" type="range" min="100" max="1000" step="50" value="500"></label>
  </div>
  <div id="shapes"></div>
  <div id="canvas-container"><canvas id="game" width="600" height="600"></canvas></div>
  <div id="rules">
    <p><strong>Rules:</strong></p>
    <ul>
      <li>Live with 2â€“3 neighbors</li>
      <li>Dead becomes live with exactly 3 neighbors</li>
      <li>Otherwise death or stays dead</li>
    </ul>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const cellSize = 20;
    const rows = canvas.height / cellSize;
    const cols = canvas.width / cellSize;
    let grid = Array.from({length:rows}, () => Array(cols).fill(0));
    let running = false, interval = null, speed = 500;
    let preview = null, currentRotation = 0;

    const shapes = {
      glider: [[0,1],[1,2],[2,0],[2,1],[2,2]],
      blinker: [[0,1],[1,1],[2,1]],
      toad: [[1,1],[1,2],[1,3],[2,0],[2,1],[2,2]],
      beacon: [[0,0],[0,1],[1,0],[2,3],[3,2],[3,3]],
      lwss: [[0,1],[0,4],[1,0],[2,0],[3,0],[3,4],[1,5],[2,5],[3,5]]
    };

    function rotate(shape, angle) {
      return shape.map(([y, x]) => {
        switch (angle) {
          case 90: return [x, -y];
          case 180: return [-y, -x];
          case 270: return [-x, y];
          default: return [y, x];
        }
      });
    }

    function drawGrid() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          ctx.fillStyle = grid[y][x] ? '#000' : '#fff';
          ctx.fillRect(x*cellSize, y*cellSize, cellSize, cellSize);
          ctx.strokeStyle = '#ccc';
          ctx.strokeRect(x*cellSize, y*cellSize, cellSize, cellSize);
        }
      }
      if (preview) {
        const shape = rotate(preview.shape, currentRotation);
        ctx.fillStyle = 'rgba(30,144,255,0.4)';
        ctx.strokeStyle = '#1e90ff';
        shape.forEach(([dy, dx]) => {
          const px = (preview.x + dx)*cellSize;
          const py = (preview.y + dy)*cellSize;
          if (px>=0 && py>=0 && px<canvas.width && py<canvas.height) {
            ctx.save();
            ctx.beginPath();
            ctx.rect(px+0.5, py+0.5, cellSize-1, cellSize-1);
            ctx.fill();
            ctx.stroke();
            ctx.restore();
          }
        });
      }
    }

    function step() {
      const newG = grid.map(r => [...r]);
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          let n = 0;
          for (let dy=-1; dy<=1; dy++) {
            for (let dx=-1; dx<=1; dx++) {
              if (dx || dy) {
                const yy = y+dy, xx = x+dx;
                if (yy>=0 && yy<rows && xx>=0 && xx<cols) n += grid[yy][xx];
              }
            }
          }
          newG[y][x] = grid[y][x] ? (n===2 || n===3) : n===3;
        }
      }
      grid = newG;
      drawGrid();
    }

    // Controls
    document.getElementById('start').onclick = () => { if (!running) { running=true; interval = setInterval(step, speed); } };
    document.getElementById('stop').onclick = () => { running=false; clearInterval(interval); };
    document.getElementById('clear').onclick = () => { grid = grid.map(r => r.fill(0)); drawGrid(); };
    document.getElementById('speed').oninput = e => { speed = +e.target.value; if (running) { clearInterval(interval); interval = setInterval(step, speed); } };

    // Cell toggle
    canvas.addEventListener('click', e => {
      if (running) return;
      const r = canvas.getBoundingClientRect();
      const x = Math.floor((e.clientX - r.left)/cellSize);
      const y = Math.floor((e.clientY - r.top)/cellSize);
      grid[y][x] = grid[y][x] ? 0 : 1;
      drawGrid();
    });

    // Palette
    const shapesDiv = document.getElementById('shapes');
    Object.entries(shapes).forEach(([name, coords]) => {
      const div = document.createElement('div');
      div.className = 'shape'; div.draggable = true; div.dataset.shape = name;
      const maxY = Math.max(...coords.map(c => c[0]));
      const maxX = Math.max(...coords.map(c => c[1]));
      const gridContainer = document.createElement('div');
      gridContainer.style.display = 'grid';
      gridContainer.style.gridTemplateRows = `repeat(${maxY+1}, 10px)`;
      gridContainer.style.gridTemplateColumns = `repeat(${maxX+1}, 10px)`;
      gridContainer.style.gap = '1px';
      coords.forEach(([dy, dx]) => {
        const cell = document.createElement('div');
        cell.style.width = '10px'; cell.style.height = '10px';
        cell.style.background = '#000';
        cell.style.gridRowStart = dy + 1;
        cell.style.gridColumnStart = dx + 1;
        gridContainer.appendChild(cell);
      });
      div.appendChild(gridContainer);
      const lbl = document.createElement('div'); lbl.textContent = name; div.appendChild(lbl);
      div.addEventListener('dragstart', e => { preview = null; div.style.opacity = 0.5; e.dataTransfer.setData('shape', name); });
      div.addEventListener('dragend', () => { div.style.opacity = 1; preview = null; drawGrid(); });
      shapesDiv.appendChild(div);
    });

    // Drag/drop
    canvas.addEventListener('dragover', e => {
      e.preventDefault();
      const r = canvas.getBoundingClientRect();
      const x = Math.floor((e.clientX - r.left)/cellSize);
      const y = Math.floor((e.clientY - r.top)/cellSize);
      const sn = e.dataTransfer.getData('shape');
      if (shapes[sn]) { preview = {shape: shapes[sn], x, y}; drawGrid(); }
    });
    canvas.addEventListener('dragleave', () => { preview = null; drawGrid(); });
    canvas.addEventListener('drop', e => {
      e.preventDefault();
      if (running) return;
      const r = canvas.getBoundingClientRect();
      const x = Math.floor((e.clientX - r.left)/cellSize);
      const y = Math.floor((e.clientY - r.top)/cellSize);
      const sn = e.dataTransfer.getData('shape');
      if (shapes[sn]) {
        rotate(shapes[sn], currentRotation).forEach(([dy, dx]) => {
          const yy = y + dy, xx = x + dx;
          if (yy>=0 && yy<rows && xx>=0 && xx<cols) grid[yy][xx] = 1;
        });
        preview = null;
        drawGrid();
      }
    });

    drawGrid();
  </script>
</body>
</html>
